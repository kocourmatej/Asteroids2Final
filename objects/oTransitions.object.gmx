<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-99999</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>nextRoom = -1; //The room to transition to.
transition = 0; //The selected transition.
steps = 30; //The transition time in steps.
color = c_black; //The transition color (if needed).
jam = true; //Whether or not to jam the keyboard and mouse - by doing this, no keyboard or mouse input will be recogniced during the transition.

count = 0; //Counting how far into the transition we are.

/*
 Here we create a new surface, and draw our application
 surface onto it. This works as a screenshot of the current
 room. 
*/
surface = surface_create(surface_get_width(application_surface),surface_get_height(application_surface));
surface_set_target(surface);
draw_clear(c_black);
draw_enable_alphablend(false);
draw_set_colour_write_enable(true,true,true,false);
draw_surface(application_surface,0,0);
draw_set_colour_write_enable(true,true,true,true);
draw_enable_alphablend(true);
surface_reset_target();

//This is our second surface, only needed for some of our transition types.
surface2 = surface_create(surface_get_width(application_surface),surface_get_height(application_surface));

//We want to make all our foregrounds invisible, or else they will be drawn on top of the transition.
for(i=0;i&lt;8;i++){
 bVis[i] = background_visible[i];
 if background_foreground[i] == true {
  background_visible[i] = false;
 }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clean up
//We free our surfaces from memory, and re-enables our foregrounds.
surface_free(surface);
surface_free(surface2);
for(i=0;i&lt;8;i++){
 background_visible[i] = bVis[i];
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Functioning
count++; //We add one to our counter.

//If our counter surpasses our transition-length we destroy the object, and thereby ends the transition.
if count &gt; steps {
 instance_destroy();
}

//By using io_clear in the begin step event we stop input from having effect.
if jam == true {
 io_clear();
}

/*
 If any of the surfaces are not existing for some reason, we simply skip the
 transition by going to the next room (if not already there) and destroying
 this object.
*/
/*
if !surface_exists(surface) || !surface_exists(surface2) {
 if room != nextRoom {
  room_goto(nextRoom);
 }
 instance_destroy();
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>for(i=0;i&lt;8;i++){
 bVis[i] = background_visible[i];
 if background_foreground[i] == true {
  background_visible[i] = false;
 }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var __guiW = display_get_gui_width();
var __guiH = display_get_gui_height();


 
   if room != nextRoom {
  room_goto(nextRoom);
 }
 
 draw_surface_stretched_ext(surface,-__guiW/2*count/steps,-__guiH/2*count/steps,__guiW+count/steps*__guiW,__guiH+count/steps*__guiH,c_white,1-count/steps);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>for(i=0;i&lt;8;i++){
 if background_foreground[i] == true &amp;&amp; bVis[i] == true {
  draw_background(background_index[i],background_x[i],background_y[i]);
  draw_background(background_index[i],background_x[i],background_y[i]);
 }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
